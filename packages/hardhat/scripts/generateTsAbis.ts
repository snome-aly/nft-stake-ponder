/**
 * generateTsAbis.ts - ç”Ÿæˆå‰ç«¯ ABI ç±»å‹å®šä¹‰è„šæœ¬
 *
 * âš ï¸ é‡è¦ï¼šé™¤éä½ çŸ¥é“è‡ªå·±åœ¨åšä»€ä¹ˆï¼Œå¦åˆ™ä¸è¦ä¿®æ”¹æˆ–åˆ é™¤æ­¤è„šæœ¬
 *
 * åŠŸèƒ½ï¼š
 * 1. è¯»å– deployments/ ç›®å½•ä¸‹çš„æ‰€æœ‰éƒ¨ç½²ä¿¡æ¯
 * 2. æå–æ¯ä¸ªåˆçº¦çš„ ABIã€åœ°å€ã€ç»§æ‰¿å‡½æ•°ç­‰
 * 3. ç”Ÿæˆ TypeScript ç±»å‹å®šä¹‰æ–‡ä»¶
 * 4. è¾“å‡ºåˆ° packages/nextjs/contracts/deployedContracts.ts
 *
 * è§¦å‘æ—¶æœºï¼š
 * - æ¯æ¬¡è¿è¡Œ `yarn deploy` åè‡ªåŠ¨æ‰§è¡Œ
 * - åœ¨ hardhat.config.ts çš„ task("deploy") ä¸­è¢«è°ƒç”¨
 *
 * ä½œç”¨ï¼š
 * - å‰ç«¯ Scaffold-ETH hooks éœ€è¦è¿™ä¸ªæ–‡ä»¶æ¥è·å–åˆçº¦ä¿¡æ¯
 * - abitype ä¼šæ ¹æ® ABI è‡ªåŠ¨æ¨å¯¼ TypeScript ç±»å‹
 * - ç¡®ä¿å‰ç«¯å§‹ç»ˆä½¿ç”¨æœ€æ–°çš„åˆçº¦æ¥å£
 */

import * as fs from "fs";
import prettier from "prettier"; // ç”¨äºæ ¼å¼åŒ–ç”Ÿæˆçš„ä»£ç 
import { DeployFunction } from "hardhat-deploy/types";

// ç”Ÿæˆæ–‡ä»¶çš„é¡¶éƒ¨æ³¨é‡Š
// è­¦å‘Šç”¨æˆ·ï¼šè¿™æ˜¯è‡ªåŠ¨ç”Ÿæˆçš„æ–‡ä»¶ï¼Œä¸è¦æ‰‹åŠ¨ä¿®æ”¹
const generatedContractComment = `
/**
 * This file is autogenerated by Scaffold-ETH.
 * You should not edit it manually or your changes might be overwritten.
 */
`;

// éƒ¨ç½²ä¿¡æ¯ç›®å½•ï¼ˆhardhat-deploy æ’ä»¶ç”Ÿæˆï¼‰
const DEPLOYMENTS_DIR = "./deployments";
// ç¼–è¯‘äº§ç‰©ç›®å½•ï¼ˆHardhat ç¼–è¯‘å™¨ç”Ÿæˆï¼‰
const ARTIFACTS_DIR = "./artifacts";

/**
 * è·å–ç›®å½•ä¸‹çš„æ‰€æœ‰å­ç›®å½•åç§°
 * @param path - ç›®æ ‡ç›®å½•è·¯å¾„
 * @returns å­ç›®å½•åç§°æ•°ç»„
 *
 * ç¤ºä¾‹ï¼šgetDirectories("./deployments") -> ["hardhat", "sepolia", "mainnet"]
 */
function getDirectories(path: string) {
  return fs
    .readdirSync(path, { withFileTypes: true }) // è¯»å–ç›®å½•ï¼Œè¿”å› Dirent å¯¹è±¡æ•°ç»„
    .filter(dirent => dirent.isDirectory()) // åªä¿ç•™ç›®å½•
    .map(dirent => dirent.name); // æå–ç›®å½•å
}

/**
 * è·å–ç›®å½•ä¸‹çš„æ‰€æœ‰åˆçº¦åç§°ï¼ˆä» JSON æ–‡ä»¶åæå–ï¼‰
 * @param path - ç›®æ ‡ç›®å½•è·¯å¾„
 * @returns åˆçº¦åç§°æ•°ç»„
 *
 * ç¤ºä¾‹ï¼šgetContractNames("./deployments/sepolia")
 *       -> ["YourContract", "NFTStaking"]ï¼ˆä» YourContract.json æå–ï¼‰
 */
function getContractNames(path: string) {
  return fs
    .readdirSync(path, { withFileTypes: true }) // è¯»å–ç›®å½•
    .filter(dirent => dirent.isFile() && dirent.name.endsWith(".json")) // åªä¿ç•™ JSON æ–‡ä»¶
    .map(dirent => dirent.name.split(".")[0]); // æå–æ–‡ä»¶åï¼ˆå»æ‰ .jsonï¼‰
}

/**
 * è·å–åˆçº¦ç»§æ‰¿çš„çˆ¶åˆçº¦åˆ—è¡¨
 * @param sources - ç¼–è¯‘å…ƒæ•°æ®ä¸­çš„æºç æ˜ å°„
 * @param contractName - åˆçº¦åç§°
 * @returns çˆ¶åˆçº¦æ–‡ä»¶åæ•°ç»„
 *
 * ä½œç”¨ï¼šè§£æ Solidity æºç ï¼Œæå–ç»§æ‰¿å…³ç³»
 * ç¤ºä¾‹ï¼šcontract YourContract is Ownable, Pausable
 *       -> ["Ownable.sol", "Pausable.sol"]
 */
function getActualSourcesForContract(sources: Record<string, any>, contractName: string) {
  // éå†æ‰€æœ‰æºæ–‡ä»¶è·¯å¾„
  for (const sourcePath of Object.keys(sources)) {
    // ä»è·¯å¾„ä¸­æå–æ–‡ä»¶åï¼ˆå»æ‰ .solï¼‰
    // ä¾‹å¦‚ï¼š"contracts/YourContract.sol" -> "YourContract"
    const sourceName = sourcePath.split("/").pop()?.split(".sol")[0];

    if (sourceName === contractName) {
      // æ‰¾åˆ°ç›®æ ‡åˆçº¦çš„æºç 
      const contractContent = sources[sourcePath].content as string;

      // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…ç»§æ‰¿å£°æ˜
      // åŒ¹é…æ ¼å¼ï¼šcontract ContractName is ParentContract1, ParentContract2 {
      const regex = /contract\s+(\w+)\s+is\s+([^{}]+)\{/;
      const match = contractContent.match(regex);

      if (match) {
        // match[2] æ˜¯ç»§æ‰¿éƒ¨åˆ†ï¼Œä¾‹å¦‚ï¼š"Ownable, Pausable"
        const inheritancePart = match[2];

        // åˆ†å‰²å¹¶æ•´ç†çˆ¶åˆçº¦åç§°
        const inheritedContracts = inheritancePart.split(",").map(contract => `${contract.trim()}.sol`);

        return inheritedContracts;
      }
      return []; // æ²¡æœ‰ç»§æ‰¿å…³ç³»
    }
  }
  return []; // æœªæ‰¾åˆ°åˆçº¦
}

/**
 * è·å–ä»çˆ¶åˆçº¦ç»§æ‰¿çš„å‡½æ•°æ˜ å°„
 * @param sources - ç¼–è¯‘å…ƒæ•°æ®ä¸­çš„æºç æ˜ å°„
 * @param contractName - åˆçº¦åç§°
 * @returns ç»§æ‰¿å‡½æ•°æ˜ å°„ { å‡½æ•°å: æºæ–‡ä»¶è·¯å¾„ }
 *
 * ä½œç”¨ï¼šæ ‡è®°å“ªäº›å‡½æ•°æ˜¯ä»çˆ¶åˆçº¦ç»§æ‰¿çš„
 * ç”¨é€”ï¼šå‰ç«¯å¯ä»¥åŒºåˆ†è‡ªæœ‰å‡½æ•°å’Œç»§æ‰¿å‡½æ•°
 */
function getInheritedFunctions(sources: Record<string, any>, contractName: string) {
  // è·å–çˆ¶åˆçº¦åˆ—è¡¨
  const actualSources = getActualSourcesForContract(sources, contractName);
  const inheritedFunctions = {} as Record<string, any>;

  // éå†æ¯ä¸ªçˆ¶åˆçº¦
  for (const sourceContractName of actualSources) {
    // åœ¨æºç ä¸­æŸ¥æ‰¾çˆ¶åˆçº¦çš„æ–‡ä»¶è·¯å¾„
    const sourcePath = Object.keys(sources).find(key => key.includes(`/${sourceContractName}`));

    if (sourcePath) {
      // ä»è·¯å¾„ä¸­æå–åˆçº¦åç§°
      const sourceName = sourcePath?.split("/").pop()?.split(".sol")[0];

      // è¯»å–çˆ¶åˆçº¦çš„ç¼–è¯‘äº§ç‰©ï¼ˆåŒ…å« ABIï¼‰
      const { abi } = JSON.parse(fs.readFileSync(`${ARTIFACTS_DIR}/${sourcePath}/${sourceName}.json`).toString());

      // éå†çˆ¶åˆçº¦çš„æ‰€æœ‰å‡½æ•°
      for (const functionAbi of abi) {
        if (functionAbi.type === "function") {
          // è®°å½•å‡½æ•°åå’Œæ¥æº
          inheritedFunctions[functionAbi.name] = sourcePath;
        }
      }
    }
  }

  return inheritedFunctions;
}

/**
 * ä» deployments ç›®å½•è¯»å–æ‰€æœ‰éƒ¨ç½²ä¿¡æ¯
 * @returns æŒ‰ chainId ç»„ç»‡çš„åˆçº¦æ•°æ®
 *
 * è¿”å›æ ¼å¼ï¼š
 * {
 *   "31337": {  // chainId (hardhat æœ¬åœ°ç½‘ç»œ)
 *     "YourContract": {
 *       address: "0x5FbDB...",
 *       abi: [...],
 *       inheritedFunctions: { "owner": "contracts/Ownable.sol" },
 *       deployedOnBlock: 1
 *     }
 *   },
 *   "11155111": {  // chainId (sepolia æµ‹è¯•ç½‘)
 *     "YourContract": { ... }
 *   }
 * }
 */
function getContractDataFromDeployments() {
  // æ£€æŸ¥ deployments ç›®å½•æ˜¯å¦å­˜åœ¨
  if (!fs.existsSync(DEPLOYMENTS_DIR)) {
    throw Error("At least one other deployment script should exist to generate an actual contract.");
  }

  const output = {} as Record<string, any>;

  // è·å–æ‰€æœ‰ç½‘ç»œç›®å½•ï¼ˆä¾‹å¦‚ï¼šhardhat, sepolia, mainnetï¼‰
  const chainDirectories = getDirectories(DEPLOYMENTS_DIR);

  for (const chainName of chainDirectories) {
    let chainId;
    try {
      // è¯»å– .chainId æ–‡ä»¶è·å–é“¾ ID
      // hardhat-deploy ä¼šåœ¨æ¯ä¸ªç½‘ç»œç›®å½•ä¸‹åˆ›å»ºè¿™ä¸ªæ–‡ä»¶
      chainId = fs.readFileSync(`${DEPLOYMENTS_DIR}/${chainName}/.chainId`).toString();
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    } catch (error) {
      console.log(`No chainId file found for ${chainName}`);
      continue; // è·³è¿‡æ²¡æœ‰ chainId çš„ç›®å½•
    }

    // å­˜å‚¨å½“å‰é“¾ä¸Šçš„æ‰€æœ‰åˆçº¦
    const contracts = {} as Record<string, any>;

    // éå†å½“å‰ç½‘ç»œç›®å½•ä¸‹çš„æ‰€æœ‰åˆçº¦
    for (const contractName of getContractNames(`${DEPLOYMENTS_DIR}/${chainName}`)) {
      // è¯»å–åˆçº¦çš„éƒ¨ç½²ä¿¡æ¯ JSON æ–‡ä»¶
      // hardhat-deploy ä¼šä¸ºæ¯ä¸ªéƒ¨ç½²çš„åˆçº¦ç”Ÿæˆä¸€ä¸ª JSON æ–‡ä»¶
      const { abi, address, metadata, receipt } = JSON.parse(
        fs.readFileSync(`${DEPLOYMENTS_DIR}/${chainName}/${contractName}.json`).toString(),
      );

      // æå–ç»§æ‰¿çš„å‡½æ•°ï¼ˆå¦‚æœæœ‰ metadataï¼‰
      const inheritedFunctions = metadata ? getInheritedFunctions(JSON.parse(metadata).sources, contractName) : {};

      // ç»„è£…åˆçº¦æ•°æ®
      contracts[contractName] = {
        address, // åˆçº¦åœ°å€
        abi, // åˆçº¦ ABI
        inheritedFunctions, // ç»§æ‰¿çš„å‡½æ•°æ˜ å°„
        deployedOnBlock: receipt?.blockNumber, // éƒ¨ç½²æ—¶çš„åŒºå—å·
      };
    }

    // ä»¥ chainId ä¸ºé”®å­˜å‚¨åˆçº¦æ•°æ®
    output[chainId] = contracts;
  }

  return output;
}

/**
 * ç”Ÿæˆ TypeScript åˆçº¦å®šä¹‰æ–‡ä»¶ï¼ˆä¸»å‡½æ•°ï¼‰
 *
 * è¿™ä¸ªå‡½æ•°ä¼šï¼š
 * 1. ä» deployments ç›®å½•è¯»å–æ‰€æœ‰éƒ¨ç½²ä¿¡æ¯
 * 2. ç”Ÿæˆ TypeScript ä»£ç 
 * 3. ä½¿ç”¨ Prettier æ ¼å¼åŒ–ä»£ç 
 * 4. å†™å…¥åˆ°å‰ç«¯çš„ contracts ç›®å½•
 *
 * æ­¤è„šæœ¬åº”è¯¥åœ¨éƒ¨ç½²å®Œæˆåè¿è¡Œï¼ˆhardhat.config.ts ä¸­é…ç½®ï¼‰
 */
const generateTsAbis: DeployFunction = async function () {
  // ç›®æ ‡ç›®å½•ï¼šå‰ç«¯çš„ contracts æ–‡ä»¶å¤¹
  const TARGET_DIR = "../nextjs/contracts/";

  // è¯»å–æ‰€æœ‰éƒ¨ç½²ä¿¡æ¯
  const allContractsData = getContractDataFromDeployments();

  // ç”Ÿæˆæ–‡ä»¶å†…å®¹ï¼šå°†åˆçº¦æ•°æ®è½¬æ¢ä¸º TypeScript å¯¹è±¡å­—é¢é‡
  // æ ¼å¼ï¼š31337: { YourContract: {...} }, 11155111: { YourContract: {...} }
  const fileContent = Object.entries(allContractsData).reduce((content, [chainId, chainConfig]) => {
    return `${content}${parseInt(chainId).toFixed(0)}:${JSON.stringify(chainConfig, null, 2)},`;
  }, "");

  // ç¡®ä¿ç›®æ ‡ç›®å½•å­˜åœ¨
  if (!fs.existsSync(TARGET_DIR)) {
    fs.mkdirSync(TARGET_DIR);
  }

  // ç”Ÿæˆå®Œæ•´çš„ TypeScript æ–‡ä»¶å†…å®¹
  const tsFileContent = `${generatedContractComment} import { GenericContractsDeclaration } from "~~/utils/scaffold-eth/contract"; \n\n
 const deployedContracts = {${fileContent}} as const; \n\n export default deployedContracts satisfies GenericContractsDeclaration`;

  // ä½¿ç”¨ Prettier æ ¼å¼åŒ–ä»£ç 
  const formattedContent = await prettier.format(tsFileContent, {
    parser: "typescript", // ä½¿ç”¨ TypeScript è§£æå™¨
  });

  // å†™å…¥æ–‡ä»¶
  fs.writeFileSync(`${TARGET_DIR}deployedContracts.ts`, formattedContent);

  console.log(`ğŸ“ Updated TypeScript contract definition file on ${TARGET_DIR}deployedContracts.ts`);
};

// å¯¼å‡ºå‡½æ•°ä¾› hardhat-deploy ä½¿ç”¨
export default generateTsAbis;
